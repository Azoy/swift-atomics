//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Atomics open source project
//
// Copyright (c) 2020 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

%{
  from gyb_utils import (
    autogenerated_warning, loadOrderings, storeOrderings, updateOrderings,
    boolOperations, integerOperations, lowerFirst, argLabel)

  types = [
    ("Int",        "Int",    "12", "23"),
    ("Int8",       "Int8",   "12", "23"),
    ("Int16",      "Int16",  "12", "23"),
    ("Int32",      "Int32",  "12", "23"),
    ("Int64",      "Int64",  "12", "23"),
    ("UInt",       "UInt",   "12", "23"),
    ("UInt8",      "UInt8",  "12", "23"),
    ("UInt16",     "UInt16", "12", "23"),
    ("UInt32",     "UInt32", "12", "23"),
    ("UInt64",     "UInt64", "12", "23"),

    ("Bool",       "Bool",   "true", "false"),
    ("DoubleWord", "DoubleWord", "DoubleWord(high: 100, low: 64)", "DoubleWord(high: 50, low: 32)"),

    ("Pointer",                "UnsafePointer<Foo>",         "_foo1",  "_foo2"),
    ("OptionalPointer",        "UnsafePointer<Foo>?",        "nil",    "_foo2"),
    ("MutablePointer",         "UnsafeMutablePointer<Foo>",  "_mfoo1", "_mfoo2"),
    ("OptionalMutablePointer", "UnsafeMutablePointer<Foo>?", "nil",    "_mfoo2"),
    ("RawPointer",             "UnsafeMutableRawPointer",    "_raw1",  "_raw2"),
    ("OptionalRawPointer",     "UnsafeMutableRawPointer?",   "nil",    "_raw2"),

    ("Unmanaged",              "Unmanaged<Bar>",             "_bar1", "_bar2"),
    ("OptionalUnmanaged",      "Unmanaged<Bar>?",            "nil",   "_bar2"),

    ("Reference",              "Baz",  "_baz1", "_baz2"),
    ("OptionalReference",      "Baz?", "nil",   "_baz2"),

    ("RawRepresentable", "Fred", "Fred.one", "Fred.two"),
  ]
}%
${autogenerated_warning()}

import XCTest
import Atomics

extension Unmanaged: Equatable { // FIXME: This is terrible
  public static func ==(left: Self, right: Self) -> Bool {
    left.toOpaque() == right.toOpaque()
  }
}

private struct Foo: Equatable, CustomStringConvertible {
  var value: Int
  init(_ value: Int) { self.value = value }
  var description: String { "Foo(\(value))" }
}

private class Bar: Equatable, CustomStringConvertible {
  var value: Int
  init(_ value: Int) { self.value = value }
  var description: String { "Bar(\(value))" }
  static func ==(left: Bar, right: Bar) -> Bool {
    left === right
  }
}

private class Baz: Equatable, CustomStringConvertible, AtomicReference {
  var value: Int
  init(_ value: Int) { self.value = value }
  var description: String { "Bar(\(value))" }
  static func ==(left: Baz, right: Baz) -> Bool {
    left === right
  }
}

private enum Fred: Int, AtomicValue {
  case one
  case two
}

/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicTests: XCTestCase {
  private let _mfoo1: UnsafeMutablePointer<Foo> = {
    let p = UnsafeMutablePointer<Foo>.allocate(capacity: 1)
    p.initialize(to: Foo(1))
    return p
  }()

  private let _mfoo2: UnsafeMutablePointer<Foo> = {
    let p = UnsafeMutablePointer<Foo>.allocate(capacity: 1)
    p.initialize(to: Foo(2))
    return p
  }()

  private var _foo1: UnsafePointer<Foo> { UnsafePointer(_mfoo1) }
  private var _foo2: UnsafePointer<Foo> { UnsafePointer(_mfoo2) }

  private let _raw1 = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1)
  private let _raw2 = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1)
  private let _bar1 = Unmanaged<Bar>.passRetained(Bar(1))
  private let _bar2 = Unmanaged<Bar>.passRetained(Bar(2))
  private let _baz1 = Baz(1)
  private let _baz2 = Baz(2)

  deinit {
    _mfoo1.deinitialize(count: 1)
    _mfoo1.deallocate()

    _mfoo2.deinitialize(count: 1)
    _mfoo2.deallocate()

    _raw1.deallocate()
    _raw2.deallocate()

    _bar1.release()
    _bar2.release()
  }

% for label, type, a, b in types:
  func test_${label}_create_destroy() {
    let v = UnsafeAtomic<${type}>.create(${a})
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), ${a})

    let w = UnsafeAtomic<${type}>.create(${b})
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), ${b})
  }

% for (order, _) in loadOrderings:
  func test_${label}_load_${order}() {
    let v = UnsafeAtomic<${type}>.create(${a})
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .${order}), ${a})

    let w = UnsafeAtomic<${type}>.create(${b})
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .${order}), ${b})
  }
% end

% for (order, _) in storeOrderings:
  func test_${label}_store_${order}() {
    let v = UnsafeAtomic<${type}>.create(${a})
    defer { v.destroy() }
    v.store(${b}, ordering: .${order})
    XCTAssertEqual(v.load(ordering: .relaxed), ${b})

    let w = UnsafeAtomic<${type}>.create(${b})
    defer { w.destroy() }
    w.store(${a}, ordering: .${order})
    XCTAssertEqual(w.load(ordering: .relaxed), ${a})
  }
% end

% for (order, _, _) in updateOrderings:
  func test_${label}_exchange_${order}() {
    let v = UnsafeAtomic<${type}>.create(${a})
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(${a}, ordering: .${order}), ${a})
    XCTAssertEqual(v.load(ordering: .relaxed), ${a})

    XCTAssertEqual(v.exchange(${b}, ordering: .${order}), ${a})
    XCTAssertEqual(v.load(ordering: .relaxed), ${b})

    XCTAssertEqual(v.exchange(${b}, ordering: .${order}), ${b})
    XCTAssertEqual(v.load(ordering: .relaxed), ${b})
  }
% end

% for (order, _, _) in updateOrderings:
  func test_${label}_compareExchange_${order}() {
    let v = UnsafeAtomic<${type}>.create(${a})
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: ${a},
      desired: ${b},
      ordering: .${order})
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, ${a})
    XCTAssertEqual(v.load(ordering: .relaxed), ${b})

    (exchanged, original) = v.compareExchange(
      expected: ${a},
      desired: ${b},
      ordering: .${order})
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, ${b})
    XCTAssertEqual(v.load(ordering: .relaxed), ${b})

    (exchanged, original) = v.compareExchange(
      expected: ${b},
      desired: ${a},
      ordering: .${order})
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, ${b})
    XCTAssertEqual(v.load(ordering: .relaxed), ${a})

    (exchanged, original) = v.compareExchange(
      expected: ${b},
      desired: ${a},
      ordering: .${order})
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, ${a})
    XCTAssertEqual(v.load(ordering: .relaxed), ${a})
  }
% end

% for operation in ["compareExchange", "weakCompareExchange"]:
%   for (successorder, _, _) in updateOrderings:
%     for (failorder, _) in loadOrderings:
  func test_${label}_${operation}_${successorder}_${failorder}() {
    let v = UnsafeAtomic<${type}>.create(${a})
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: ${a},
      desired: ${b},
      successOrdering: .${successorder},
      failureOrdering: .${failorder})
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, ${a})
    XCTAssertEqual(v.load(ordering: .relaxed), ${b})

    (exchanged, original) = v.compareExchange(
      expected: ${a},
      desired: ${b},
      successOrdering: .${successorder},
      failureOrdering: .${failorder})
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, ${b})
    XCTAssertEqual(v.load(ordering: .relaxed), ${b})

    (exchanged, original) = v.compareExchange(
      expected: ${b},
      desired: ${a},
      successOrdering: .${successorder},
      failureOrdering: .${failorder})
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, ${b})
    XCTAssertEqual(v.load(ordering: .relaxed), ${a})

    (exchanged, original) = v.compareExchange(
      expected: ${b},
      desired: ${a},
      successOrdering: .${successorder},
      failureOrdering: .${failorder})
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, ${a})
    XCTAssertEqual(v.load(ordering: .relaxed), ${a})
  }
%     end
%   end
% end


// Bool operations

% if type == "Bool":
%   for (name, _, operator, arglabel, _) in boolOperations:
%     for (order, _, _) in updateOrderings:
  func test_${label}_loadThen${name}_${order}() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThen${name}(${argLabel(arglabel)}b, ordering: .${order})
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a ${operator} b,
          "a = \(a), b =\(b)")
      }
    }
  }
%     end
%   end

%   for (name, _, operator, arglabel, _) in boolOperations:
%     for (order, _, _) in updateOrderings:
  func test_${label}_${lowerFirst(name)}ThenLoad_${order}() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.${lowerFirst(name)}ThenLoad(
          ${argLabel(arglabel)}b,
          ordering: .${order})
        XCTAssertEqual(r, a ${operator} b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a ${operator} b,
          "a = \(a), b =\(b)")
      }
    }
  }
%     end
%   end
% end

// Integer operations

% if type.startswith("Int") or type.startswith("UInt"):
%   for (name, _, operator, arglabel, _) in integerOperations:
%     for (order, _, _) in updateOrderings:
  func test_${label}_loadThen${name}_${order}() {
    let a: ${type} = 3
    let b: ${type} = 8
    let c: ${type} = 12
    let result1: ${type} = a ${operator} b
    let result2: ${type} = result1 ${operator} c

    let v = UnsafeAtomic<${type}>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThen${name}(${argLabel(arglabel)}b, ordering: .${order})
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThen${name}(${argLabel(arglabel)}c, ordering: .${order})
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
%     end
%   end

%   for (name, _, operator, arglabel, _) in integerOperations:
%     for (order, _, _) in updateOrderings:
  func test_${label}_${lowerFirst(name)}ThenLoad_${order}() {
    let a: ${type} = 3
    let b: ${type} = 8
    let c: ${type} = 12
    let result1: ${type} = a ${operator} b
    let result2: ${type} = result1 ${operator} c

    let v = UnsafeAtomic<${type}>.create(a)
    defer { v.destroy() }

    let new1 = v.${lowerFirst(name)}ThenLoad(${argLabel(arglabel)}b, ordering: .${order})
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.${lowerFirst(name)}ThenLoad(${argLabel(arglabel)}c, ordering: .${order})
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
%     end
%   end
% end

% end
}
